---
title: Godot Engine에서의 게임-엔진 경계
published: 2025-12-18
tags: [프로젝트, 엔지니어링, 공부]
category: Game Engine
draft: false
---
## 게임과 엔진의 경계
게임 엔진은 게임이라는 의존성을 주입받아 동작하는 프로그램이다. 그러면 이제, 그 의존성을 어떻게 주입받을 것인가에 관한 문제가 남는다. 모든 프로그램이 데이터와 로직 두 가지로 이루져있고 게임 엔진도 마찬가지인 것처럼, 게임도 (흔히 리소스나 에셋이라 부르는) 데이터와 (스크립트로 이루어진) 로직으로 이루어져있다고 볼 수 있다. 그렇다면, 게임 엔진이 주입받아야 하는 의존성도 크게 이 둘로 나누어볼 수 있다. 데이터는 `Assimp`나 `stb_image`같은 외부 라이브러리가 로드해주는 경우도 있고, 간단한 경우(작은 이진 파일이나, 텍스트)에는 직접 리소스 로더를 만들어볼 수도 있겠다. 그리고 로직은 어떤 언어를 쓰느냐에 따라 나뉘는데, (이론적으로는 어떤 언어든 쓸 수 있지만) 주로 다음 둘 정도로 나누어 생각해볼 수 있다.
첫 번째로는, 엔진과 같은 코드를 사용하여 엔진과 함께 이진 코드로 번역되는 경우이다. C/C++같은 컴파일 언어를 사용한다면, 엔진이라고 불리는 프레임워크와 함께 게임이 컴파일된 후에 게임의 배포가 이루어질 것이다. 이 방식의 장점은, 새로운 언어를 배우지 않아도 된다는 것이다. 또, 하나의 컴파일러에서 빌드될 것이므로, (괜찮은 컴파일러라면) 약간의 최적화도 기대해볼 수 있을 것이다. 그리고 디버깅하기도 훨씬 쉽다.
```cpp
int main(int argc, char* argv[]){
	MyGame game;
	GameEngine engine(&game);
	
	engine.run();
}
```
두 번째로는, 엔진과 다른 코드 특히 스크립트 언어를 사용하여 엔진이 Scene이 로드되는 과정에서 스크립트가 이진 코드로 번역되는 경우이다. Unreal Engine은 `Angelscript`를 사용하고, Unity Engine은 `C#`을 사용한다. 또, Godot Engine은 (Python에서 영감을 받아 만든) `GDScript`를 사용한다. 가장 유명한 3대 엔진 모두 스크립트 언어를 사용하는 이유가 뭘까? 가장 큰 이유는 게임 코드는 아주아-주 자주 변경되기 때문이다. 만약, 게임 캐릭터가 원하는 대로 동작하는지 확인하기 위해 엔진을 끄고->수정 사항과 함께 빌드 후->다시 엔진을 키고...를 반복해야한다면, 꽤나 고통스러울 것이다.
```cpp
int main(int argc, char* argv[]){
	// argv[1]: "MyScene.toml" or "MyScene.json", whatever.
	auto scene = SceneParser::parse(argv[1]);
	GameEngine engine(&scene);
	
	engine.run();
}
```

---
## Godot Engine에서 "게임"이란
Godot Engine은 .tscn 파일(Text Scene)로 씬을 관리하고 gd파일(Godot Script)을 스크립트로 사용한다. tscn파일은 toml파일처럼 씬의 트리 구조를 표현할 수 있다. 트리 구조라는 뜻은 노드의 의존성을 따라서 로드된다는 뜻이다. 예를 들어서, 아래의 `box`라는 노드는, `SubResource`와 `ExtResource`에 대해 의존성을 가지고 있다는 것을 확인할 수 있다. 즉, Godot Engine은 씬 데이터(tscn)과 스크립트의 해석기이고, 이 씬 데이터와 스크립트가 곧 Godot Engine에서의 게임이다.
```
[gd_scene load_steps=6 format=1]

[ext_resource path="res://input.gd" type="Script" id=1]

[sub_resource type="RectangleShape2D" id=1]

custom_solver_bias = 0.0
extents = Vector2( 64, 64 )

[node name="box" type="Area2D" parent="."]

transform/pos = Vector2( 212, 281 )
transform/rot = 35.4081
shapes/0/shape = SubResource( 1 )
script/script = ExtResource( 1 )
```

## 예전에 시도했던 것
이전에 나도 Godot Engine과 (의도한 건 아니지만...) 비슷한 시도를 한 적이 있다. 스크립트 언어가 따로 분리되어서 에디터에서 즉시 조작하는 게 굉장히 멋있어 보이지 않은가! 그래서, Angelscript와 toml로 비슷하게 만들었었다.

|        | Godot Engine | My Engine |
| :----: | -----------: | --------: |
| Scene  |        .tscn |     .toml |
| Script |          .gd |       .as |

하지만, C++의 구조체를 Angelscript에 하나하나 알려줘야한다는 게 너무 귀찮았고, 무엇보다 스크립트 엔진 관리하는 게 은근히 빡세서, 점점 코드가 늘어날수록 뭔가 커플링이 심해져서 금방 접었다.